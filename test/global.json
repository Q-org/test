{     clearImmediate: [Function: clearImmediate],
      setImmediate: [Function: setImmediate] {
        [Symbol(nodejs.util.promisify.custom)]: [Getter]
      },
      clearInterval: [Function: clearInterval],
      clearTimeout: [Function: clearTimeout],
      setInterval: [Function: setInterval],
      setTimeout: [Function: setTimeout] {
        [Symbol(nodejs.util.promisify.custom)]: [Getter]
      },
      queueMicrotask: [Function: queueMicrotask],
      structuredClone: [Function: structuredClone],
      atob: [Function: atob],
      btoa: [Function: btoa],
      performance: Performance {
        nodeTiming: PerformanceNodeTiming {
          name: 'node',
          entryType: 'node',
          startTime: 0,
          duration: 1551.1143,
          nodeStart: 1.596400000154972,
          v8Start: 13.087099999189377,
          bootstrapComplete: 41.59519999846816,
          environment: 22.900199998170137,
          loopStart: 55.227199997752905,
          loopExit: -1,
          idleTime: 0
        },
        timeOrigin: 1715616398818.821
      },
      fetch: [Function: value],
      navigator: Navigator {},
      crypto: Crypto {},
      global: [Circular *1],
      Buffer: [Function: Buffer] {
        poolSize: 8192,
        from: [Function: from],
        copyBytesFrom: [Function: copyBytesFrom],
        of: [Function: of],
        alloc: [Function: alloc],
        allocUnsafe: [Function: allocUnsafe],
        allocUnsafeSlow: [Function: allocUnsafeSlow],
        isBuffer: [Function: isBuffer],
        compare: [Function: compare],
        isEncoding: [Function: isEncoding],
        concat: [Function: concat],
        byteLength: [Function: byteLength],
        [Symbol(kIsEncodingSymbol)]: [Function: isEncoding]
      },
      ArrayBuffer: [Function: ArrayBuffer],
      Uint8Array: [Function: Uint8Array],
      console: CustomConsole [console] {
        log: [Function: log],
        warn: [Function: warn],
        dir: [Function: dir],
        time: [Function: time],
        timeEnd: [Function: timeEnd],
        timeLog: [Function: timeLog],
        trace: [Function: trace],
        assert: [Function: assert],
        clear: [Function: clear],
        count: [Function: count],
        countReset: [Function: countReset],
        group: [Function: group],
        groupEnd: [Function: groupEnd],
        table: [Function: table],
        debug: [Function: debug],
        info: [Function: info],
        dirxml: [Function: dirxml],
        error: [Function: error],
        groupCollapsed: [Function: groupCollapsed],
        _stdout: Socket {
          connecting: false,
          _hadError: false,
          _parent: null,
          _host: null,
          _closeAfterHandlingError: false,
          _events: [Object],
          _readableState: [ReadableState],
          _writableState: [WritableState],
          allowHalfOpen: false,
          _maxListeners: undefined,
          _writev: null,
          _write: [Function (anonymous)],
          _eventsCount: 1,
          _sockname: null,
          _pendingData: null,
          _pendingEncoding: '',
          server: null,
          _server: null,
          _type: 'pipe',
          fd: 1,
          _isStdio: true,
          destroySoon: [Function (anonymous)],
          _destroy: [Function: dummyDestroy],
          [Symbol(async_id_symbol)]: 9,
          [Symbol(kHandle)]: [Pipe],
          [Symbol(lastWriteQueueSize)]: 0,
          [Symbol(timeout)]: null,
          [Symbol(kBuffer)]: null,
          [Symbol(kBufferCb)]: null,
          [Symbol(kBufferGen)]: null,
          [Symbol(shapeMode)]: true,
          [Symbol(kCapture)]: false,
          [Symbol(kSetNoDelay)]: false,
          [Symbol(kSetKeepAlive)]: false,
          [Symbol(kSetKeepAliveInitialDelay)]: 0,
          [Symbol(kBytesRead)]: 0,
          [Symbol(kBytesWritten)]: 0
        },
        _stderr: Socket {
          connecting: false,
          _hadError: false,
          _parent: null,
          _host: null,
          _closeAfterHandlingError: false,
          _events: [Object],
          _readableState: [ReadableState],
          _writableState: [WritableState],
          allowHalfOpen: false,
          _maxListeners: undefined,
          _writev: null,
          _write: [Function (anonymous)],
          _eventsCount: 1,
          _sockname: null,
          _pendingData: null,
          _pendingEncoding: '',
          server: null,
          _server: null,
          _type: 'pipe',
          fd: 1,
          _isStdio: true,
          destroySoon: [Function (anonymous)],
          _destroy: [Function: dummyDestroy],
          [Symbol(async_id_symbol)]: 9,
          [Symbol(kHandle)]: [Pipe],
          [Symbol(lastWriteQueueSize)]: 0,
          [Symbol(timeout)]: null,
          [Symbol(kBuffer)]: null,
          [Symbol(kBufferCb)]: null,
          [Symbol(kBufferGen)]: null,
          [Symbol(shapeMode)]: true,
          [Symbol(kCapture)]: false,
          [Symbol(kSetNoDelay)]: false,
          [Symbol(kSetKeepAlive)]: false,
          [Symbol(kSetKeepAliveInitialDelay)]: 0,
          [Symbol(kBytesRead)]: 0,
          [Symbol(kBytesWritten)]: 0
        },
        _formatBuffer: [Function: consoleFormatter],
        _counters: {},
        _timers: {},
        _groupDepth: 0,
        Console: [Function: Console]
      },
      afterAll: [Function: afterAll],
      afterEach: [Function: afterEach],
      beforeAll: [Function: beforeAll],
      beforeEach: [Function: beforeEach],
      describe: [Function: describe] {
        each: [Function: bindWrap],
        only: [Function: only] { each: [Function: bindWrap] },
        skip: [Function: skip] { each: [Function: bindWrap] }
      },
      it: [Function: test] {
        todo: [Function (anonymous)],
        each: [Function: bindWrap],
        failing: [Function: failing] { each: [Function: bindWrap] },
        only: [Function: only] { each: [Function: bindWrap], failing: [Function] },
        skip: [Function: skip] { each: [Function: bindWrap], failing: [Function] },
        concurrent: [Function: concurrentTest] {
          each: [Function: bindWrap],
          only: [Function],
          skip: [Function],
          failing: [Function]
        }
      },
      test: [Function: test] {
        todo: [Function (anonymous)],
        each: [Function: bindWrap],
        failing: [Function: failing] { each: [Function: bindWrap] },
        only: [Function: only] { each: [Function: bindWrap], failing: [Function] },
        skip: [Function: skip] { each: [Function: bindWrap], failing: [Function] },
        concurrent: [Function: concurrentTest] {
          each: [Function: bindWrap],
          only: [Function],
          skip: [Function],
          failing: [Function]
        }
      },
      fdescribe: [Function: only] { each: [Function: bindWrap] },
      fit: [Function: only] {
        each: [Function: bindWrap],
        failing: [Function: failing] { each: [Function: bindWrap] }
      },
      xdescribe: [Function: skip] { each: [Function: bindWrap] },
      xit: [Function: skip] {
        each: [Function: bindWrap],
        failing: [Function: failing] { each: [Function: bindWrap] }
      },
      xtest: [Function: skip] {
        each: [Function: bindWrap],
        failing: [Function: failing] { each: [Function: bindWrap] }
      },
      expect: [Function: expect] {
        extend: [Function (anonymous)],
        addEqualityTesters: [Function (anonymous)],
        anything: [Function: anything],
        any: [Function: any],
        not: {
          arrayContaining: [Function: arrayNotContaining],
          closeTo: [Function: notCloseTo],
          objectContaining: [Function: objectNotContaining],
          stringContaining: [Function: stringNotContaining],
          stringMatching: [Function: stringNotMatching],
          toMatchInlineSnapshot: [Function: value],
          toMatchSnapshot: [Function: value],
          toThrowErrorMatchingInlineSnapshot: [Function: value],
          toThrowErrorMatchingSnapshot: [Function: value]
        },
        arrayContaining: [Function: arrayContaining],
        closeTo: [Function: closeTo],
        objectContaining: [Function: objectContaining],
        stringContaining: [Function: stringContaining],
        stringMatching: [Function: stringMatching],
        assertions: [Function: assertions],
        hasAssertions: [Function: hasAssertions],
        getState: [Function: getState],
        setState: [Function: setState],
        extractExpectedAssertionsErrors: [Function: extractExpectedAssertionsErrors],
        toMatchInlineSnapshot: [Function: value],
        toMatchSnapshot: [Function: value],
        toThrowErrorMatchingInlineSnapshot: [Function: value],
        toThrowErrorMatchingSnapshot: [Function: value],
        addSnapshotSerializer: [Function: addSerializer]
      }
    }
